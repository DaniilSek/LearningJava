# LearningJava

## 1. Объясните концепцию полиморфизма в Java и приведите пример.
Это когда объекты разных классов могут обрабатываться как объекты одного и того же суперкласса, но при этом их поведение будет зависеть от конкретного типа объекта. Например есть класс **Animal**, от него наследуются классы **Dog** и **Cat**, у данных классов может быть одинаковый с **Animal** метод **whatAnimalSay()**, но у **Dog** допустим будет вывод "Гав", а у **Cat** будет вывод "Мяу".
```Java
class Animal {
    public void whatAnimalSay() { System.out.println("..."); }
}

class Dog extends Animal {
    @Override
public void whatAnimalSay() { System.out.println("Гав"); }
}

class Cat extends Animal {
    @Override
public void whatAnimalSay() { System.out.println("Мяу"); }
}

// Использование полиморфизма:
Animal animal = new Dog();
animal.whatAnimalSay(); // Выведет "Гав"
```
## 2. Что означает ключевое слово final перед объявлением переменной или метода?
**final** перед переменной означает, что она не может быть изменена, например:
```Java
final int x = 10;
x = 20; // тут будет ошибка компиляции
```
**final** перед методом запрещает переопределение метода. Также **final** может стоять перед классом, это означает, что класс нельзя наследовать.

## 3. Расскажите, что такое цикл сборщика мусора (GC) в Java и как он работает?
Сборщик мусора - это компонент виртуальной машины Java (JVM), который автоматически освобождает память, он периодически проверяет наличие ссылок на объект. Объекты, на которые больше нет активных ссылок, считаются мусором и подлежат удалению.
1. Когда программа создает новый объект, память выделяется в куче (heap).
2. После завершения работы с объектом ссылка на него теряется.
3. Через некоторое время сборщик мусора определяет, что этот объект никому не нужен, и освобождает занимаемую им память.

## 4. Какие ключевые особенности многопоточности в Java вам известны?
У каждого потока свой стек, но общая память: локальные переменные потокобезопасны, но объекты в heap могут быть общими и требуют синхронизации. Если два потока одновременно изменяют один объект, то возможна гонка за данные (Race Condition).Механизм synchronized, нужен для синхронизации. Например:public synchronized void doWork() {}только один поток сможет войти в этот метод при одном экземпляре объекта. Ключевое слово volatile: Используется для примитивных типов данных, чтобы гарантировать видимость изменений среди потоков. Гарантирует атомичность чтения и записи значений, но не обеспечивает защиту сложных операций над ними.

## 5. Опишите разницу между методами equals() и hashCode(). Почему важно соблюдать связь между этими двумя методами?
Метод equals() используется для сравнения двух объектов по содержимому (логическому равенству).
Метод hashCode() вычисляет уникальный числовой идентификатор объекта. 
Если два объекта равны согласно equals(), то их hashCode() обязательно должен возвращать одно и то же значение. Когда переопределяешь для какого-то класса equals, то и hashCode необходимо переопределить.

## 6. Перечислите три ключевых преимущества использования Collection Framework в Java.
Collection Framework предоставляет единый набор удобных интерфейсов List, Set, Map, Queue.
Легко менять реализацию без изменения логики: например, ArrayList → LinkedList, HashMap -> LinkedHashMap.
Все представленные типы данных имеют реализации с добавлением и удалением объектов внутри себя, а также поиск элементов.

## 7. Назовите три способа обработки исключений в Java.
1. Обработка через try-catch блок, где исключение перехватывается и обрабатывается внутри метода;
2. Проброс исключения через throws, в этом случае исключение не обрабатывается внутри текущего метода, оно отправляется коду, вызвавшему этот метод;
3. Использование try-with-resources, позволяет автоматически закрывать ресурсы, реализующие интерфейс AutoCloseable. Например при открытии текстового файла.
