# LearningJava

## 1. Объясните концепцию полиморфизма в Java и приведите пример.
Это когда объекты разных классов могут обрабатываться как объекты одного и того же суперкласса, но при этом их поведение будет зависеть от конкретного типа объекта. Например есть класс **Animal**, от него наследуются классы **Dog** и **Cat**, у данных классов может быть одинаковый с **Animal** метод **whatAnimalSay()**, но у **Dog** допустим будет вывод "Гав", а у **Cat** будет вывод "Мяу".
```Java
class Animal {
    public void whatAnimalSay() { System.out.println("..."); }
}

class Dog extends Animal {
    @Override
public void whatAnimalSay() { System.out.println("Гав"); }
}

class Cat extends Animal {
    @Override
public void whatAnimalSay() { System.out.println("Мяу"); }
}

// Использование полиморфизма:
Animal animal = new Dog();
animal.whatAnimalSay(); // Выведет "Гав"
```
## 2. Что означает ключевое слово final перед объявлением переменной или метода?
**final** перед переменной означает, что она не может быть изменена, например:
```Java
final int x = 10;
x = 20; // тут будет ошибка компиляции
```
**final** перед методом запрещает переопределение метода. Также **final** может стоять перед классом, это означает, что класс нельзя наследовать.

## 3. Расскажите, что такое цикл сборщика мусора (GC) в Java и как он работает?
Сборщик мусора - это компонент виртуальной машины Java (JVM), который автоматически освобождает память, он периодически проверяет наличие ссылок на объект. Объекты, на которые больше нет активных ссылок, считаются мусором и подлежат удалению.
1. Когда программа создает новый объект, память выделяется в куче (heap).
2. После завершения работы с объектом ссылка на него теряется.
3. Через некоторое время сборщик мусора определяет, что этот объект никому не нужен, и освобождает занимаемую им память.

## 4. Какие ключевые особенности многопоточности в Java вам известны?
У каждого потока свой стек, но общая память: локальные переменные потокобезопасны, но объекты в heap могут быть общими и требуют синхронизации. Если два потока одновременно изменяют один объект, то возможна гонка за данные (Race Condition).Механизм synchronized, нужен для синхронизации. Например:public synchronized void doWork() {}только один поток сможет войти в этот метод при одном экземпляре объекта. Ключевое слово volatile: Используется для примитивных типов данных, чтобы гарантировать видимость изменений среди потоков. Гарантирует атомичность чтения и записи значений, но не обеспечивает защиту сложных операций над ними.

## 5. Опишите разницу между методами equals() и hashCode(). Почему важно соблюдать связь между этими двумя методами?
Метод equals() используется для сравнения двух объектов по содержимому (логическому равенству).
Метод hashCode() вычисляет уникальный числовой идентификатор объекта. 
Если два объекта равны согласно equals(), то их hashCode() обязательно должен возвращать одно и то же значение. Когда переопределяешь для какого-то класса equals, то и hashCode необходимо переопределить.
```Java
public class Person {
    private String name;
    private int age;
    
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (!(obj instanceof Person)) return false;
        
        Person other = (Person) obj;
        return Objects.equals(name, other.name) && age == other.age;
    }

    public int hashCode() {
        return Objects.hash(name, age);
    }
}

HashMap<Person, Integer> map = new HashMap<>();
Person p1 = new Person("Alice", 30);
Person p2 = new Person("Alice", 30);

map.put(p1, 1);
System.out.println(map.get(p2)); // 1
System.out.println(p1.equals(p2)); // true
```

## 6. Перечислите три ключевых преимущества использования Collection Framework в Java.
Collection Framework предоставляет единый набор удобных интерфейсов List, Set, Map, Queue.
Легко менять реализацию без изменения логики: например, ArrayList → LinkedList, HashMap -> LinkedHashMap.
Все представленные типы данных имеют реализации с добавлением и удалением объектов внутри себя, а также поиск элементов.

## 7. Назовите три способа обработки исключений в Java.
1. Обработка через try-catch блок, где исключение перехватывается и обрабатывается внутри метода;
2. Проброс исключения через throws, в этом случае исключение не обрабатывается внутри текущего метода, оно отправляется коду, вызвавшему этот метод;
3. Использование try-with-resources, позволяет автоматически закрывать ресурсы, реализующие интерфейс AutoCloseable. Например при открытии текстового файла.

## 8. Что такое класс Object в Java и почему он важен?
Все классы **Java** наследуют от класса **Object** методы **equals()** и **hashCode()**. Данные методы помогают проверять равенство объектов и осуществлять поиск по хэшкоду объекта. Если переопределяется метод **equals()**, то и **hashCode()** следует переопределить, чтобы не было коллизий. Также часто используемый метод **toString()** для представления объекта в виде строки, который тоже можно переопределить для конкретного объекта.

## 9. Объясните разницу между ==, equals() и compareTo() методами в Java. Когда какой из них следует использовать?
1. Оператор ==: Проверяет, ссылаются ли две переменные на один и тот же объект в памяти или сравнивает примитивные типы.
2. Метод equals(): Используется для семантического сравнения двух объектов, проверяя, равны ли их состояния. Необходимо переопределять этот метод в собственных классах, если нужно сравнивать содержимое объектов.
3. Метод compareTo(): Применяется в интерфейсе Comparable. Этот метод возвращает отрицательное число, ноль или положительное число, показывая порядок следования элементов при сортировке.

## 10. Что означает термин “исключение” (exception) в Java? Какие бывают виды исключений и какова разница между ними?
Исключение — это событие, которое нарушает нормальный ход выполнения программы.Все исключения происходят их класса java.lang.Throwable:
```Java
Throwable
├── Error → системные фатальные ошибки (не нужно и не стоит ловить)
└── Exception
    ├── RuntimeException → непроверяемые исключения (Unchecked Exception)
    └── Checked Exceptions → проверяемые исключения
```
1. **Checked Exceptions** - должны быть объявлены или обработаны с помощью try-catch или throws. Компилятор проверяет их наличие и выдаст предупреждение, что такая ошибка может возникнуть при выполнении программы и ее стоит обработать.
Примеры:
**IOException
SQLException
URISyntaxException
ClassNotFoundException**
2. **Unchecked Exception** - не требуют обязательной проверки, могут возникнуть в любом контексте. 
Примеры:
**NullPointerException
IllegalArgumentException
ArrayIndexOutOfBoundsException
ArithmeticException** (например, деление на 0)
3. **Error** - фатальные проблемы с которыми приложение не может бороться, не требуют перехвата.
Примеры:
**OutOfMemoryError** — закончилась память
**StackOverflowError** — бесконечная рекурсия
**NoClassDefFoundError** — класс был, но не найден при запуске

## 11. Опишите принцип работы механизма сборки мусора (GC) в Java. Какие существуют стратегии GC и как выбрать подходящую стратегию для приложения?
Принцип работы **Garbage Collector (GC)**:
**Heap** делится на поколения:
1. **Young Generation** (Молодое поколение): Новые объекты попадают сюда изначально. Эта область быстро освобождается, поскольку большинство новых объектов умирают вскоре после своего создания.
2. **Old Generation** (Старое поколение): Здесь хранятся долгоживущие объекты, которые пережили очистку **Young Generation**.
3. **Permanent Generation** (Перманентное поколение): Содержит метаданные классов и структуры JVM (до Java 8).
Сборщик работает следующим образом:
1. **Маркировка живых объектов**: Объекты, достижимые из корней (локальных переменных, стека вызовов), помечаются как "живые".
2. **Удаление мертвых объектов**: Немытые объекты собираются и уничтожаются.
3. **Компактирование**: Оставшиеся объекты перемещаются, уплотняя память.
**Основные алгоритмы GC**:
**Serial Collector**: Простой последовательный алгоритм. Подходит для небольших приложений и однопроцессорных машин.
**Parallel Collector**: Выполняет уборку параллельно, улучшая производительность на многоядерных системах.
**CMS (Concurrent Mark-Sweep)**: Работает одновременно с приложением, уменьшая паузы остановки.
**G1 (Garbarge First)**: Современный алгоритм, используемый по умолчанию в большинстве случаев. Ориентирован на минимизацию задержек и позволяет задать цели производительности.
Выбор подходящей стратегии зависит от требований приложения:
Для серверных приложений предпочтителен **G1** или **CMS**.
Для небольших десктоп-приложений подойдет **Serial** или **Parallel**.
