# LearningJava

## 1. Объясните концепцию полиморфизма в Java и приведите пример.
Это когда объекты разных классов могут обрабатываться как объекты одного и того же суперкласса, но при этом их поведение будет зависеть от конкретного типа объекта. Например, есть класс **Animal**, от него наследуются классы **Dog** и **Cat**, у данных классов может быть одинаковый с классом **Animal** метод **whatAnimalSay()**, но у **Dog** допустим будет вывод "Гав", а у **Cat** будет вывод "Мяу".
```Java
class Animal {
    public void whatAnimalSay() { System.out.println("..."); }
}

class Dog extends Animal {
    @Override
public void whatAnimalSay() { System.out.println("Гав"); }
}

class Cat extends Animal {
    @Override
public void whatAnimalSay() { System.out.println("Мяу"); }
}

// Использование полиморфизма:
Animal animal = new Dog();
animal.whatAnimalSay(); // Выведет "Гав"
```
## 2. Что означает ключевое слово final перед объявлением переменной или метода?
**final** перед переменной означает, что она не может быть изменена, например:
```Java
final int x = 10;
x = 20; // тут будет ошибка компиляции
```
**final** перед методом запрещает переопределение метода. Также **final** может стоять перед классом, это означает, что класс нельзя наследовать.

## 3. Расскажите, что такое цикл сборщика мусора (GC) в Java и как он работает?
Сборщик мусора - это компонент виртуальной машины **Java (JVM)**, который автоматически освобождает память, он периодически проверяет наличие ссылок на объект. Объекты, на которые больше нет активных ссылок, считаются мусором и подлежат удалению.
1. Когда программа создает новый объект, память выделяется в куче (**heap**).
2. После завершения работы с объектом ссылка на него теряется.
3. Через некоторое время сборщик мусора определяет, что этот объект никому не нужен, и освобождает занимаемую им память.

## 4. Какие ключевые особенности многопоточности в Java вам известны?
У каждого потока свой стек, но общая память: локальные переменные потокобезопасны, но объекты в **heap** могут быть общими и требуют синхронизации. Если два потока одновременно изменяют один объект, то возможна гонка за данные (**Race Condition**).
Механизм **synchronized**, нужен для синхронизации. Например:
```Java
public synchronized void doWork() {
    System.out.println("synchronized");
}
```
только один поток сможет войти в этот метод при одном экземпляре объекта. 
Ключевое слово **volatile**: Используется для примитивных типов данных, чтобы гарантировать видимость изменений среди потоков. Гарантирует атомичность чтения и записи значений, но не обеспечивает защиту сложных операций над ними.

## 5. Опишите разницу между методами equals() и hashCode(). Почему важно соблюдать связь между этими двумя методами?
Метод **equals()** используется для сравнения двух объектов по содержимому (логическому равенству).
Метод **hashCode()** вычисляет уникальный числовой идентификатор объекта. 
Если два объекта равны согласно **equals()**, то их **hashCode()** обязательно должен возвращать одно и то же значение. Когда переопределяешь для какого-то класса **equals()**, то и **hashCode()** необходимо переопределить.
```Java
public class Person {
    private String name;
    private int age;
    
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (!(obj instanceof Person)) return false;
        
        Person other = (Person) obj;
        return Objects.equals(name, other.name) && age == other.age;
    }

    public int hashCode() {
        return Objects.hash(name, age);
    }
}

HashMap<Person, Integer> map = new HashMap<>();
Person p1 = new Person("Alice", 30);
Person p2 = new Person("Alice", 30);

map.put(p1, 1);
System.out.println(map.get(p2)); // 1
System.out.println(p1.equals(p2)); // true
```

## 6. Перечислите три ключевых преимущества использования Collection Framework в Java.
**Collection Framework** предоставляет единый набор удобных интерфейсов **List, Set, Map, Queue**.
Легко менять реализацию без изменения логики: например, **ArrayList → LinkedList**, **HashMap -> LinkedHashMap**.
Все представленные типы данных имеют реализации с добавлением и удалением объектов внутри себя, а также поиск элементов.

## 7. Назовите три способа обработки исключений в Java.
1. Обработка через **try-catch** блок, где исключение перехватывается и обрабатывается внутри метода;
2. Проброс исключения через **throws**, в этом случае исключение не обрабатывается внутри текущего метода, оно отправляется коду, вызвавшему этот метод;
3. Использование **try-with-resources**, позволяет автоматически закрывать ресурсы, реализующие интерфейс **AutoCloseable**. Например при открытии текстового файла.

## 8. Что такое класс Object в Java и почему он важен?
Все классы **Java** наследуют от класса **Object** методы **equals()** и **hashCode()**. Данные методы помогают проверять равенство объектов и осуществлять поиск по хэшкоду объекта. Если переопределяется метод **equals()**, то и **hashCode()** следует переопределить, чтобы не было коллизий. Также часто используемый метод **toString()** для представления объекта в виде строки, который тоже можно переопределить для конкретного объекта.

## 9. Объясните разницу между ==, equals() и compareTo() методами в Java. Когда какой из них следует использовать?
1. Оператор ==: Проверяет, ссылаются ли две переменные на один и тот же объект в памяти или сравнивает примитивные типы.
2. Метод **equals()**: Используется для семантического сравнения двух объектов, проверяя, равны ли их состояния. Необходимо переопределять этот метод в собственных классах, если нужно сравнивать содержимое объектов.
3. Метод **compareTo()**: Применяется в интерфейсе **Comparable**. Этот метод возвращает отрицательное число, ноль или положительное число, показывая порядок следования элементов при сортировке.

## 10. Что означает термин “исключение” (exception) в Java? Какие бывают виды исключений и какова разница между ними?
Исключение — это событие, которое нарушает нормальный ход выполнения программы.Все исключения происходят их класса **java.lang.Throwable**:
```Java
Throwable
├── Error → системные фатальные ошибки (не нужно и не стоит ловить)
└── Exception
    ├── RuntimeException → непроверяемые исключения (Unchecked Exception)
    └── Checked Exceptions → проверяемые исключения
```
1. **Checked Exceptions** - должны быть объявлены или обработаны с помощью **try-catch** или **throws**. Компилятор проверяет их наличие и выдаст предупреждение, что такая ошибка может возникнуть при выполнении программы и ее стоит обработать.
Примеры:
**IOException
SQLException
URISyntaxException
ClassNotFoundException**
2. **Unchecked Exception** - не требуют обязательной проверки, могут возникнуть в любом контексте (ошибки логики программы). 
Примеры:
**NullPointerException
IllegalArgumentException
ArrayIndexOutOfBoundsException
ArithmeticException** (например, деление на 0)
3. **Error** - фатальные проблемы с которыми приложение не может бороться, не требуют перехвата.
Примеры:
**OutOfMemoryError** — закончилась память
**StackOverflowError** — бесконечная рекурсия
**NoClassDefFoundError** — класс был, но не найден при запуске

## 11. Опишите принцип работы механизма сборки мусора (GC) в Java. Какие существуют стратегии GC и как выбрать подходящую стратегию для приложения?
Принцип работы **Garbage Collector (GC)**:
**Heap** делится на поколения:
1. **Young Generation** (Молодое поколение): Новые объекты попадают сюда изначально. Эта область быстро освобождается, поскольку большинство новых объектов умирают вскоре после своего создания.
2. **Old Generation** (Старое поколение): Здесь хранятся долгоживущие объекты, которые пережили очистку **Young Generation**.
3. **Permanent Generation** (Перманентное поколение): Содержит метаданные классов и структуры **JVM** (до Java 8).
Сборщик работает следующим образом:
1. **Маркировка живых объектов**: Объекты, достижимые из корней (локальных переменных, стека вызовов), помечаются как "живые".
2. **Удаление мертвых объектов**: Недостижимые объекты собираются и уничтожаются.
3. **Компактирование**: Оставшиеся объекты перемещаются, уплотняя память.
**Основные алгоритмы GC**:
**Serial Collector**: Простой последовательный алгоритм. Подходит для небольших приложений и однопроцессорных машин.
**Parallel Collector**: Выполняет сборку мусора параллельно, улучшая производительность на многоядерных системах.
**CMS (Concurrent Mark-Sweep)**: Работает одновременно с приложением, уменьшая паузы остановки.
**G1 (Garbarge First)**: Современный алгоритм, используемый по умолчанию в большинстве случаев. Ориентирован на минимизацию задержек и позволяет задать цели производительности.
Выбор подходящей стратегии зависит от требований приложения:
Для серверных приложений предпочтителен **G1** или **CMS**.
Для небольших десктоп-приложений подойдет **Serial** или **Parallel**.

## 12. Объясните разницу между интерфейсами Collection, List и Set. Приведите пример ситуации, когда лучше использовать каждый из них
Эти три интерфейса являются частью **Java Collection Framework** и связаны между собой по наследованию.
```Java
Collection (интерфейс)
├── List (интерфейс)
│   ├── ArrayList
│   ├── LinkedList
│   └── Vector
└── Set (интерфейс)
    ├── HashSet
    ├── LinkedHashSet
    └── TreeSet
```
**List<E>**
Интерфейс **List** представляет упорядоченную коллекцию элементов, допускающую дублирование. Каждый элемент имеет индекс, доступ к нему осуществляется по этому индексу. Это полезно, когда порядок важен и нужен быстрый доступ к элементам по индексу. Например, список товаров в корзине покупателя.
**Set<E>**
Интерфейс **Set** гарантирует уникальность элементов внутри коллекции. Порядок хранения не гарантируется (если не используется **SortedSet**). Полезно, когда важно отсутствие повторяющихся значений. Например, хранение уникальных идентификаторов пользователей.

## 13. Что такое дженерики (Generics) в Java и зачем они нужны?
Дженерики (**Generics**) — это механизм параметризации типов, он позволяет писать классы, интерфейсы и методы, которые работают с произвольными типами, при этом сохраняя типобезопасность на этапе компиляции. 
```Иными словами - Дженерики позволяют создавать "шаблоны", где тип указывается при использовании, а не при написании кода.``` 
Все коллекции (**List, Set, Map**) используют дженерики.
```Java
List<String> list = new ArrayList<>();
list.add("Привет");
// list.add(123); → Ошибка компиляции
String s = list.get(0); // Не нужно приведение типов
```
```Java
public class Box<T> {
    private T content;
    
    public void setContent(T t) { this.content = t; }
    public T getContent() { return content; }
}

Box<Integer> boxInt = new Box<>(); // Хранит целые числа
boxInt.setContent(10);
Integer value = boxInt.getContent();
```

## 14. Расскажите, как устроено наследование в Java. Что значит ключевое слово final применительно к классу и методу? Можете привести пример переопределения метода?
Наследование классов в **Java**:
Один класс может наследоваться от другого, перенимая или переопределяя под себя родительские методы. Наследоваться (**extends**) можно только от одного класса, но если класс является интерфейсом, то можно имплементировать множественное кол-во интерфейсов.
Пример наследование с переопределением метода:
```Java
public class Animal {
    public void animalSound() {
        System.out.println("");
    }
}

public class Dog extends Animal {
    @Override
    public void animalSound() {
        System.out.println("Гав");
    }
}
```
**final** - означает неизменность. Если применить его к классу, то от такого класса нельзя будет наследоваться, если применить его к методу, то такой метод нельзя будет переопределить.

## 15. Опишите принцип работы многопоточности в Java. Чем отличается создание потока через реализацию интерфейса Runnable от расширения класса Thread? Какие проблемы возникают при работе с потоками и как их избежать?
Многопоточность — это способность **JVM** выполнять несколько потоков одновременно, что позволяет эффективно использовать ресурсы процессора, особенно при работе с сетью, файлами, асинхронными задачами.
1. Каждый поток — это отдельная последовательность выполнения (**thread of execution**);
2. Все потоки разделяют одну память (**heap**), но имеют собственный стек;
3. Управление потоками осуществляет **JVM** и операционная система.
Интерфейс **Runnable** определяет контракт для запуска процесса в отдельном потоке. Чтобы создать поток таким способом, нужно создать класс, реализующий интерфейс **Runnable**, а затем передать экземпляр этого класса конструктору класса **Thread**.
```Java
class MyRunnable implements Runnable {
    @Override
    public void run() {
        for(int i=0; i<5; i++) {
            System.out.println(Thread.currentThread().getName());
        }
    }
}

MyRunnable r = new MyRunnable();
Thread t1 = new Thread(r);
t1.start();
```
Когда создаётся поток путём расширения класса **Thread**, создается новый подкласс класса **Thread**. Каждый экземпляр такого подкласса представляет отдельный поток исполнения.
```Java
class MyThread extends Thread {
    @Override
    public void run() {
        for(int i=0; i<5; i++) {
            System.out.println(Thread.currentThread().getName());
        }
    }
}

MyThread t1 = new MyThread();
t1.start();
```
Итог: использовать реализацию интерфейса **Runnable** предпочтительнее, поскольку это способствует лучшей структуре программы и сохраняет её открытость для повторного использования и расширения.
**Проблемы многопоточности:**
1. **Deadlock:** взаимоблокировка двух или более потоков, ожидающих друг друга.
2. **Race condition:** непредсказуемый результат операций, выполняемых несколькими потоками параллельно.
3. **Starvation:** ситуация, когда поток бесконечно долго ожидает ресурс.
**Решение проблем:**
1. Синхронизация методов или блоков через ключевые слова **synchronized, ReentrantLock**.
2. Использование механизма синхронизации из пакета **java.util.concurrent** (например: **CountDownLatch, CyclicBarrier**).
3. Применение паттернов проектирования, таких как **Producer-Consumer**.

## 16. Что такое сериализация объектов в Java и для чего она применяется? Какой интерфейс реализует класс, поддерживающий сериализацию?
Сериализация объектов - это преобразования объекта в поток байтов, который можно:
1. Сохранить в файл;
2. Передать по сети;
3. Хранить в базе данных;
4. Отправить через REST API.
Для этого требуется интерфейс **java.io.Serializable**
1. Процесс восстановления объекта из сохранённого состояния называется десериализацией.
2. Для контроля процесса сериализации/десериализации можно реализовать специальные методы **writeObject** и **readObject**.
3. Интерфейс **Serializable** сам по себе пустой (**marker interface**), никаких обязательных методов не требует.
4. Переменные, объявленные как **transient**, игнорируются при сериализации.
Пример (класс **Person** реализует интерфейс **Serializable**):
```Java
public static void main(String[] args) throws IOException, ClassNotFoundException {
        Person person = new Person("Иван", 30);

        // Сериализация
        try (ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream("person.ser"))) {
            out.writeObject(person);
            System.out.println("Объект сериализован");
        }

        // Десериализация
        try (ObjectInputStream in = new ObjectInputStream(new FileInputStream("person.ser"))) {
            Person restored = (Person) in.readObject();
            System.out.println("Восстановлен: " + restored.getName() + ", " + restored.getAge());
        }
    }
```
